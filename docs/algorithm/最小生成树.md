## 最小生成树

### prim算法

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N = 500 + 10;
const int M = 1e5 + 10;
const int INF = 0x3f3f3f3f;

int head[N];
int ne[M];
int idx;
int ver[M];
int w[M];
int dist[N];
int st[N];

int g[N][N];

void add(int x, int y, int z){
    ne[++idx] = head[x];
    head[x] = idx;
    ver[idx] = y;
    w[idx] = z;
}

int n,m;

int prim(){
    memset(dist,0x3f,sizeof(dist));
    dist[1] = 0;
    int cnt = 0;
    for(int i=1;i<=n;i++){
        int minPos = -1;
        for(int j=1;j<=n;j++){
            if(st[j] == false && ( minPos == -1 || dist[minPos] > dist[j]) ){
                minPos = j;
            }
        }
        cnt += dist[minPos];
        // printf("%d %d\n",minPos, n);
        st[minPos] = true;
        for(int x = 1;x<=n;x++){
            dist[x] = min(dist[x], g[minPos][x]);
        }
    }
    return cnt > INF/2?-1:cnt;
}

int main(){
    scanf("%d%d",&n,&m);
    memset(g,0x3f,sizeof(g));
    for(int i=1;i<=n;i++){
        g[i][i] = 0;
    }
    int x,y,z;
    for(int i=0;i<m;i++){
        scanf("%d%d%d",&x,&y,&z);
        g[x][y] = min(g[x][y],z);
        g[y][x] = min(g[y][x],z);
    }
    int res = prim();
    if(res == -1){
        printf("impossible");
    }else
    printf("%d",res);
    return 0;
}
```

### Kruskal算法

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 1e5 + 10;
const int M = 2e5 + 10;
int n,m;

struct Edge{
    int x;
    int y;
    int z;
};

Edge e[M];

int arr[N];

int ufind(int x){
    if(arr[x] < 0){
        return x;
    }
    return arr[x] = ufind(arr[x]);
}

int kruskal(){
    int cnt = 0;
    int ecnt = 1;
    memset(arr,-1,sizeof(arr));
    sort(e,e+m,[](const Edge &e1, const Edge &e2){
        return e1.z < e2.z;
    });
    for(int i=0;i<m;i++){
        if(ufind(e[i].x) != ufind(e[i].y)){
            // for(int i=1;i<=n;i++){
            //     printf("%d ",ufind(i));
            // }
            // printf("\n");
            arr[ufind(e[i].x)] = ufind(e[i].y);
            cnt += e[i].z;
            ecnt ++;
            // printf("%d %d\n",e[i].x,e[i].y);
        }
    }
    int p = ufind(1);
    if(ecnt != n){
        return -1;
    }
    return cnt;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++){
        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
    }
    int res=  kruskal();
    if(res == -1){
        printf("impossible");
    }else
    printf("%d", res);
    return 0;
}
```