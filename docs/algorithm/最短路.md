## 最短路

单源最短路径，如果不存在负边的情况下，可以使用Dijkstra算法，如果存在负边，可以使用Bellman-Ford算法和SPFA。

对于多源最短路径，使用Floyd算法。

这里，正无穷被定义为：

```cpp
const int INF = 0x3f3f3f3f;
```

### Dijkstra算法

Dijkstra算法的流程如下：
1. 初始化`dist[1]=0`，其余节点的`dist`值为正无穷大。`dist`是一个数组，`dist[i]`表示从起点1到节点`i`的最短路径。
2. 找到一个未被标记的、`dist[x]`的最小节点`x`，然后标记节点`x`。
3. 扫描节点`x`的所有出边`(x,y,z)`，`y`为终点，`z`为权重，若`dist[y]>dist[x]+z`，则使用`dist[x]+z`更新`dist[y]`。
4. 重复上述2~3两个步骤，直到所有节点都被标记。

```cpp
//求1号点到n号点的最短距离
int dijkstra(vector<vector<int>>& graph){
    vector<int> distance(graph.size(),INF);
    vector<int> visited(graph.size(),0);
    distance[1] = 0;
    int n = graph.size() - 1;
    for(int i=1;i<=n;i++){
        int pos = -1;
        for(int j=1;j<=n;j++){ //找到未标记节点中距离最小的值
            if(visited[j] == 0 && (pos == -1 || distance[pos] > distance[j])){
                pos = j;
            }
        }
        if(pos == n){ //如果找到n点了，可以break掉
            break;
        }
        visited[pos] = 1;
        for(int j=1;j<=n;j++){ //使用距离最小的值更新其他值
            distance[j] = min(distance[pos] + graph[pos][j],distance[j]);
        }
    }
    return distance[n] == INF?-1:distance[n];
}
```

上面程序的主要瓶颈在于寻找全局最小值的过程。可以使用二叉堆对`dist`数组进行维护。

```cpp
//求1号点到n号点的最短距离 graph邻接表 first表示终点 second表示长度
int dijkstra2(vector<vector<pair<int,int>>>& graph){
    vector<int> distance(graph.size(),INF);
    vector<int> visited(graph.size(),0);
    distance[1] = 0;
    int n = graph.size() - 1;
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
    q.push(make_pair(0,1)); //第一个是距离，第二个是顶点
    while(q.size() > 0){
        pair<int,int> top = q.top();
        q.pop();
        int x = top.second;
        if(x == n){
            break;
        }
        if(visited[x]){ //每一次更新节点都push，需要处理重复的情况
            continue;
        }
        visited[x] = 1;
        for(int i=0;i<graph[x].size();i++){
            int y = graph[x][i].first;
            int z = graph[x][i].second;
            if(distance[y] > distance[x] + z){
                distance[y] = distance[x] + z;
                q.push(make_pair(distance[y],y));
            }
        }
    }
    return distance[n] == INF?-1:distance[n];
}
```

### Bellman-Ford

### SPFA

### 判断是否有负环