## 动态规划

### 背包问题

#### 01背包

#### 完全背包

#### 多重背包

#### 分组背包

### 线性dp

#### 最长上升子序列

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N = 100000 + 10;
int arr[N];
int dp[N];

int bs(int l,int r,int x){
    int mid;
    while(l < r){
        mid = (l + r + 1)>>1;
        if(dp[mid] < x){
            l = mid;
        }else{
            r = mid - 1;
        }
    }
    return l;
}


int main(){
    int n;
    memset(dp,0x3f,sizeof(dp));
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    dp[0] = arr[0];
    int res = 1;
    int dl = 0;
    
    for(int i=1;i<n;i++){
        int pos = bs(0,dl,arr[i]); //找到第一个小于等于arr[i]的数
        if(arr[i] > dp[pos]){
            pos++;
        }
        dp[pos] = min(dp[pos],arr[i]);
        dl = max(dl,pos);
    }
    printf("%d",dl+1);
    return 0;
}
```

#### 最长公共子序列

```cpp
#include <iostream>
using namespace std;

const int N = 1010;
char str1[N];
char str2[N];
int n,m;
int dp[N][N];

int main(){
    scanf("%d%d",&n,&m);
    scanf("%s%s",str1+1,str2+1);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            if(str1[i] == str2[j]){
                dp[i][j] = max(dp[i][j],dp[i-1][j-1] + 1);
            }
        }
    }
    printf("%d",dp[n][m]);
    return 0;
}
```

#### 最短编辑距离

```cpp
#include <iostream>
using namespace std;
const int N = 1010;
int dp[N][N];
char str1[N];
char str2[N];
int n,m;

int main(){
    scanf("%d%s",&n,str1+1);
    scanf("%d%s",&m,str2+1);
    for(int i=1;i<=n;i++){
        dp[i][0] = i;
    }
    for(int j=1;j<=m;j++){
        dp[0][j] = j;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1);
            if(str1[i] == str2[j]){
                dp[i][j] = min(dp[i][j],dp[i-1][j-1]);
            }else{
                dp[i][j] = min(dp[i][j],dp[i-1][j-1]+1);
            }
        }
    }
    printf("%d",dp[n][m]);
    return 0;
}
```

### 区间DP

先枚举区间长度，然后枚举左右端点。