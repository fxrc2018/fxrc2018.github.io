## Lua元表

### 表

表是Lua语言中最主要和强大的数据结构。Lua语言中的表本质上是一种辅助数组，这种数组不仅可以用数值作为索引，也可以使用字符串或其他任意类型的值作为索引（nil除外）。

表是一种动态分配的对象，程序只能操作指向表的引用。除此以外，Lua语言不会进行隐藏的拷贝或创建新的表。

表有如下的一些初始化方式，如果对列表中一个不存在的元素赋值，那么表会创建出这个元素，并赋值；如果访问不存在的元素，则返回nil。

```lua
a = {}
a["x"] = 2
a.x = 1 -- 等价于a["x"] = 1
a = {1,2,3} -- 列表式
a = {x=0,y=1,[1] = 1} -- 记录式
-- 列表式和记录式混用
-- 注意，混用的时候，记录式最好不要用[1]=1这种形式，因为可能会被列表式的值覆盖
a = {x = 1,2,3,y = 3} 
```

Lua表的索引是从1开始的，可以使用#运算符获取序列长度。注意，#号必须作用于序列，并且中间不能存在空洞（nil）值，否则获取的值是不可靠的。

可以用pairs函数遍历一个表，可以用ipairs函数遍历一个序列。

```lua
for k,v in pairs(t) do
    print(k,v)
end
```

表标准库提供了操作列表和序列的一些常用函数。

- table.insert(pos,val) 向序列的指定位置插入一个元素，其他元素依次后移。
- table.remove(pos) 删除并返回序列指定位置的元素，然后将其后的元素向前移动填充删除元素后造成的空洞。

可以看出，这两个函数，除了在末尾插入和删除，其余情况的效率都不高，需要谨慎使用。


### 元表和元方法

通常，Lua语言中的每种类型的值都有一套可预见的操作集合。例如，我们可以将数字相加，可以连接字符串，还可以在表中插入键值对等。但是，我们无法将两个表相加，无法对函数作比较，也无法调用一个字符串，除非使用元表。

元表可以修改一个值在面对一个未知操作时的行为。例如，假如a和b都是表，那么可以通过元表定义Lua语言如何计算表达式a+b。当Lua语言试图将两个表相加时，它会先检查两者之一是否有元表且该元表中是否有__add字段。如果Lua语言找到该字段，就调用该字段对应的值，即所谓的元方法。

元表不支持继承。可以用`setmetatable(t,val)`为一个表设置元表，用`getmetatable(t)`方法得到一个表的元表。一个表还可以成为它自己的元表。

元表定义了如下一些方法：

- 算术相关的元方法
    - __add
    - __sub
    - __div
    - __idiv
    - __unm
    - __mod
    - __pow
    - __contact
- 关系运算相关的元方法
    - __eq
    - __lt
    - __le
- 库相关的元方法
    - __tostring
- 表相关的元方法
    - __index
    - __newindex

#### 表相关的元方法

表相关的元方法是Lua提供一种改变表在两种正常情况下的行为的方式，即访问和修改表中不存在的字段。

**__index元方法**

当访问表中不存在的字段时，解释器会查找一个名为__index的元方法。如果没有这个元方法，返回nil，否则，由这个元方法来提供最终结果。

值得注意的是，元方法的__index函数不一定必须是一个函数，它还可以是一个表。当元方法是一个表时，Lua语言就访问这个表。

我们可以使用`rawget(t,key)`方法绕过这套机制，只访问原始表中的元素。

**__newindex元方法**

当对一个表中不存在的索引赋值时，解释器就会查找`__newindex`元方法。如果这个元方法存在，那么解释器就调用它而不执行赋值。像元方法`__index`一样，如果这个元方法是一个表，解释器就在此表中执行赋值，而不在原始的表中进行赋值。和__index元方法一样，我们可以使用`rawset(t,k,v)`函数来绕过元方法。

结合使用元方法`__index`和`__newindex`可以实现Lua语言中一些强大的结构，例如只读的表、具有默认值的表和面向对象编程中的继承。


