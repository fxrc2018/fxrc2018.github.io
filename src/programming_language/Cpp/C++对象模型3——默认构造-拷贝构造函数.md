## C++对象模型3——默认构造-拷贝构造函数

### 默认构造函数

在C++ Primer中有一句话：只有当类没有声明任何构造函数函数时，编译器才会自动地生成默认构造函数。但并不是只要没有声明构造函数，编译器就会自动生成默认构造函数。下面是一个简单的例子：

```cpp
#include<iostream>
using namespace std;

class A{
public:
    int val;
};

int main(){
    A a;
    return 0;
}
```

可以在A类的对象这里加一个断点，然后调试，在VS2013中，调试->窗口->反汇编，就可以看到汇编代码。

```cpp
int main(){
00007FF6F79C2520  push        rdi  
00007FF6F79C2522  sub         rsp,40h  
00007FF6F79C2526  mov         rdi,rsp  
00007FF6F79C2529  mov         ecx,10h  
00007FF6F79C252E  mov         eax,0CCCCCCCCh  
00007FF6F79C2533  rep stos    dword ptr [rdi]  
    A a;
    return 0;
00007FF6F79C2535  xor         eax,eax  
}
```

在汇编代码中，我们可以发现在在构造A类的对象的时候，并没有调用A类的构造方法，说明编译器并没有为我们生成默认的构造函数。这其实取决于编译器，不同的编译器可能会有不同的结果。但是，下面这4种情况是必须生成默认构造函数的。

1. 包含一个对象类型的成员，而这个类有一个无参的构造函数。
因为成员中有一个类对象需要调用默认的构造方法，而这个默认构造方法需要在这个类中的构造方法中调用。
2. 父类有一个无参构造函数
子类需要先调用父类的构造方法，所以编译器必须生成一个默认构造函数。
3. 类中含有虚函数
如果一个类中有虚函数，那个这个类需要构造一个虚函数表，还需要在类对象中创建一个虚函数指针，然后把虚函数表的地址赋值给虚函数指针。
4. 类中有虚继承
如果类中有虚继承，那么编译器会生成虚基类表，并且改变类对象的数据布局。

可以看出，以上的情况均属于，编译器需要执行分配内存和数据初始化以外的工作，就必须构造出默认构造函数，不然无法完成对象的构造。

### 默认拷贝构造函数

如果不是必要的情况下，编译器可能不会生成默认的拷贝构造函数，而是执行逐位拷贝。必要的情况和构造函数的情况几乎是一样的：

1. 含有一个含有拷贝构造函数的类成员对象。
2. 父类含有拷贝构造函数。
3. 含有虚函数或继承了虚函数。
4. 有虚继承。

值得注意的是，默认的构造函数的拷贝方式是浅拷贝，也就是说，对于指针类型，会直接拷贝指针，而不会另外分配内存并进行拷贝。如果不注意这一点，会导致下面的错误：

```cpp
#include<iostream>
using namespace std;

class A{
public:
    char *s;
    A(){
        s = new char[100];
        strcpy_s(s, 100,"hello world");
    }

    ~A(){
        delete[]s;
    }
};

int main(){
    A *a1 = new A();
    A *a2 = new A(*a1);
    delete a1;
    delete a2;
    return 0;
}
```

delete a2会出问题，原因在于，delete a1的时候，已经释放了内存，导致了一块内存释放了两次，发生错误。

### 编译器对程序的转化

编译器会对程序进行转化，使其更容易转化为汇编代码，或使其效率更高。有时候，我们需要知道编译器的做法，对于有的情况才好理解。请看下面的代码：

```cpp
#include<iostream>
using namespace std;

class A{
public:
    int val;
    A(){
        cout << "A::A()" << endl;
    }

    A(const A& a){
        this->val = a.val;
        cout << "A(const A& a)" << endl;
    }

    ~A(){
        cout << "A::~A()" << endl;
    }

    
};

A getA(){
    A a;
    a.val = 1;
    return a;
}

void getA(A& a){
    A temp;
    temp.val = 2;
    //...
    a.A::A(temp);
}

A getA1(){
    return A();
}

int main(){
    A a1 =getA();
    cout << "----------------" << endl;
    A a2;
    getA(a2);
    cout << "a1.val = " << a1.val << " a2.val = " << a2.val << endl;
    A a3 = getA1();
    return 0;
}
```

代码比较简单，但有一个问题，getA函数会产生一个临时对象，为什么会先调用拷贝构造函数，再调用析构函数？从代码上看这是不合理的，因为函数调用完成后临时对象就应该被析构。其实，编译器把getA函数转化了一下，变成了带参数的版本，并且取消了返回值。这就比较好理解了。另外，如果把函数写成getA1的形式，编译器会进行优化，不会有临时对象产生。

### 成员初始化列表

在有些情况下，必须使用初始化列表为类中的成员赋初值：

1. 这个成员是引用
2. 如果是个const类型成员。
3. 如果继承一个没有无参构造函数的基类。
4. 如果你的成员变量类型是一个类类型，且没有无参构造函数。

上面四种情况总结起来就是，如果一个类成员没有默认初始值，那么必须在成员初始化列表中指明。使用成员初始化列表有一个值得注意的地方，就是成员初始化的顺序是声明的顺序，而不是初始化列表中的顺序。下面是一个例子：

```cpp
#include<iostream>
using namespace std;

class A{
public:
    int a;
    int b;
    A(int a, int b):b(b),a(A::b){}
};

int main(){
    A a(1,2);
    cout << a.a << " " << a.b << endl;
    return 0;
}
```

运行这个程序会出现一个现象，b被赋值成了2，但是a是一个随机值。因为在VS2013中， 类对象的不会使用默认值初始化（g++会初始化为0），而初始化顺序为a，b，但初始化a的时候，b还是随机值，然后b初始化为2。



