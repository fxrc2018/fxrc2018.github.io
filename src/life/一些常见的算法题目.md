##求最大公约数
```
/* p is greater than q */
int gcd(int p,int q){
    if(q == 0){
        return p;
    }
    int r = p % q;
    return gcd(q,r);
}
```

##判断是否为素数
```
bool isPrime(int n){
      if (n <= 3) {
        return n > 1;
    }
    int num = (int)sqrt(n);
    for (int i = 2; i <= num; i++) {
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}
```
##求n次幂

##约瑟夫环
约瑟夫环有一种递归算法，可以直接得到最后的幸存者，其基本思想是，如果只有一个人，编号为1，那么他就是幸存者；如果两个人，编号为1,2，那么这个幸存者的编号和前一次是有关系的。这里，就利用了这种推导过程，写出的代码如下。代码中没有推导的部分，推导详见左程云《程序员代码面试指南》书中的相关部分。
```
int getResult(int n, int m) {
    if(n == 1){
        return 1;
    }
    return (getResult(n-1,m) + m - 1) % n + 1;
}
```

##合法的出栈序列
已知1至n的数字序列，按顺序入栈，每个数字入栈后即可出栈，也可在栈中停留，返回等待后面的数字入栈出栈后，该数字再出栈，求该数字序列的出栈序列是否合法？

```
bool check(stack<int> &s){
    stack<int> s1;
    int n = s.size();
    for(int i=1;i<=n;i++){
        s1.push(i);
        while (s1.size() > 0 && s1.top() == s.top()){
            s1.pop();
            s.pop();
        }
    }
    if(s.size() == 0){
        return true;
    }
    return false;
}
```

##大数的加法和乘法

这个感觉还是挺常见，说是算法，其实就是模拟手工运算加法乘法，其实并不难。但后来看到别人写的程序，才发现自己写的程序太复杂了，并且思维不是很清晰，所以，参照大佬的算法，又重写写了一下。
大数加法的代码如下。
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <regex>
using namespace std;

int main(int argc, char const *argv[])
{
    string s1,s2;
    while(cin>>s1>>s2){
        regex number("[0-9]*");
        if(!regex_match(s1,number) || !regex_match(s2,number)){
            cout<<"error"<<endl;
            continue;
        }
        reverse(s1.begin(),s1.end());
        reverse(s2.begin(),s2.end());
        if(s1.size() > s2.size()){
            for(int i=0;i<s1.size() - s2.size();i++){
                s2.push_back('0');
            }
        }else if(s1.size() < s2.size()){
            for(int i=0;i<s2.size() - s1.size();i++){
                s1.push_back('0');
            }
        }
        vector<int> v( s1.size() + 1,0);
        for(int i=0;i<s1.size();i++){
            v[i] += s1[i] -  '0' + s2[i] - '0'; 
        }
        for(int i=0;i<v.size() - 1;i++){
            if(v[i] >= 10){
                v[i+1] += v[i] /10;
                v[i] %= 10;
            }
        }
        string res;
        int i;
        for(i=v.size()-1;i>0 && v[i] == 0;i--)
            ;
        for(;i>=0;i--){
            res += (char)(v[i] + '0');
        }
        cout<<res<<endl;
    }
    return 0;
}
```
大数乘法的代码如下。
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

int main(int argc, char const *argv[])
{
    string s1,s2;
    while(cin>>s1>>s2){
        reverse(s1.begin(),s1.end());
        reverse(s2.begin(),s2.end());
        vector<int> v(s1.size() + s2.size(),0);
        for(int i=0;i<s1.size();i++){
            for(int j=0;j<s2.size();j++){
                v[i+j] += (s1[i] - '0') * ( s2[j] - '0' );
            }
        }
        for(int i=0;i<v.size() - 1;i++){
            if(v[i] >= 10){
                v[i+1] += v[i] /10;
                v[i] %= 10;
            }
        }
        string res;
        int i;
        for(i=v.size()-1;i>0 && v[i] == 0;i--)
            ;
        for(;i>=0;i--){
            res += (char)(v[i] + '0');
        }
        cout<<res<<endl;
    }
    return 0;
}
```
这些代码都是在牛客网上做题的代码，所以代码中有一些和题目相关的内容。

##使用正则表达式处理字符串问题

小易喜欢的单词具有以下特性：
1.单词每个字母都是大写字母
2.单词没有连续相等的字母
3.单词没有形如“xyxy”(这里的x，y指的都是字母，并且可以相同)这样的子序列，子序列可能不连续。
例如：
小易不喜欢"ABBA"，因为这里有两个连续的'B'
小易不喜欢"THETXH"，因为这里包含子序列"THTH"
小易不喜欢"ABACADA"，因为这里包含子序列"AAAA"
小易喜欢"A","ABA"和"ABCBA"这些单词
给你一个单词，你要回答小易是否会喜欢这个单词（只要不是不喜欢，就是喜欢）。

```
#include<iostream>
#include <regex>
#include<string>
using namespace std;

bool check1(string s){
    regex r1("[A-Z]+");
    smatch results;
    return regex_match(s,results,r1);
}

bool check2(string s){
    regex r2(".*(.)(\\1).*");
    smatch results;
    return !regex_match(s,results,r2);
}

bool check3(string s){
    regex r3(".*(.).*(.).*(\\1).*(\\2).*");
    smatch results;
    return !regex_match(s,results,r3);
}

int main(int argc, char const *argv[])
{
    string s;
    cin>>s;
    if(check1(s) && check2(s) && check3(s)){
        cout<<"Likes"<<endl;
    }else{
        cout<<"Dislikes"<<endl;
    }
    return 0;
}
```



###题目的积累
在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用实践复杂度低的方法实现。

给定价格序列prices及它的长度n，请返回最大收益。保证长度小于等于500。
```
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;

int calculateMax(vector<int> prices) {
    int firstBuy = INT_MIN,firstSell = 0;
    int secondBuy = INT_MIN,secondSell = 0;
    for(int i=0;i<prices.size();i++){
        firstBuy = max(firstBuy,-prices[i]);/* find min price */
        firstSell = max(firstSell,prices[i] + firstBuy);
        secondBuy = max(secondBuy,firstSell - prices[i]);
        secondSell = max(secondSell,prices[i] + secondBuy);
    }
    return secondSell;
}
```
我觉得这个题目可以这样来想，如果只交易一次，这个是比较好写的，只需要保存当前位置前面的最小值即可，就可以算出在当前面点卖出的最大收益，然后更新这个最小值和最大收益即可。而这里有两次，这里的策略就是利用之前算出来的第一次的最大收益，把问题转化为和第一次一样的。
