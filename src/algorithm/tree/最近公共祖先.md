## 最近公共祖先

给定一颗有根树，若节点 z 既是节点 x 的祖先，也是节点 y 的祖先，则称 z 是 x,y 的公共祖先。在 x,y 的所有公共祖先中，深度最大的一个称为 x,y 的最近公共祖先，记为 LCA(x,y)。

### 向上标记法

从 x 向上走到根节点，并标记所有经过的节点。从 y 向上走到根节点，当第一次遇到已标记的节点时，就找到了 LCA(x,y)。

### 树上倍增法

树上倍增法是一个很重要的算法。除了求 LCA 之外，它在很多问题中都有广泛应用。设 F[x,y] 表示 x 的 $$2^k$$ 倍的祖先，即从 x 向根节点走 $$2^k$$ 步到达的节点。特别的，若该点不存在，则令 F[x,k] = 0。F[x,0] 就是 x 的父节点。除此之外，F[x,k] = F[F[x,k-1],k-1]，1<=k<=log n。

基于 F 数组计算 LCA(x,y) 分为以下几步：

1. 设 d[x] 表示 x 的深度。不妨设 d[x] >= d[y]（否则可以交换 x,y）。
2. 用二进制拆分的思想，把 x 向上调整到与 y 同一深度。具体来说，就是从大到小遍历 k，每次尝试走 $$2^k$$ 步，如果 到达的深度大于等于 d[y]，则令 x = F[x,k]。
3. 如果 x == y ，说明已经找到了 LCA，LCA 就等于 y。
4. 如果 x != y ，用二进制拆分的思想，把 x,y 同时向上调整，并保持深度一致且二者不会相遇。具体来说，再次从大到小遍历 K ，每次尝试走 $$2^k$$ 步，如果 F[x,k] != F[y,k]，则令 x = F[x,k]，y = F[y,k]。
5. 此时， x,y 必定只差一步就相会了，它们的父节点 F[x,0] 就是 LCA。

### tarjan算法

Tarjan算法本质上是使用并查集对 “向上标记法” 的优化。它是一个离线算法，需要把 m 个询问一次性读入，统计计算，最后统一输出。时间复杂度为 O(n+m)。

在深度优先遍历的任意时刻，树中的节点分为三类：

1. 已经访问完毕并且回溯的节点。在这些节点上标记一个整数 2。
2. 已经开始递归，但尚未回溯的节点。这些节点就是当前正在访问的节点 x 以及 x 的祖先。在这些节点上标记一个整数 1。
3. 尚未访问的节点。这些节点没有标记。

对于正在访问的节点 x，它到根节点的路径已经标记为 1。若 y 是已经访问完毕并且回溯的节点，则 LCA(x,y) 就是从 y 向上走到根，第一个遇到的标记为 1 的节点。

可以利用并查集进行优化，当一个节点获得整数 2 的标记时，把它所在的集合合并到它的父节点所在的集合中。合并时它的父节点标记一定为 1，且单独构成一个集合。

这相当于每个完成回溯的节点都有一个指针指向它的父节点，只需要查询 y 所在集合代表元素，就等价于从 y 向上一直走到一个标记为 1 的节点，即 LCA(x,y)。

对于正在访问的节点 x，扫描与 x 相关的所有询问，若询问当中的另一个点 y 的标记为 2，通过查询 y 在并查集中的代表元素就知道了 LCA(x,y)。这里需要注意的是，对于每个询问 (x, y)，需要对称的加上 (y,x)，因为遍历的顺序和查询的顺序有可能不同。此外，还需要记录每次查询的顺序。