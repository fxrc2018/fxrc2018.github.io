## DFS

### 图的深度优先遍历

深度优先遍历，就是在每个点 x 上面对多条分支时，任意选一条走下去，执行递归，直到回溯到点 x 后，再考虑其他的边。

```cpp
void dfs(int x){
    v[x] = 1; // 标记该点已经访问过了
    // 扫描这一点的所有出边
    for(int i = head[x];i != 0; i = next[i]){
        int y = ver[i]; // 边的终点
        if(v[y] == 1){
            continue;
        }
        dfs(y);
    }
}
```

深度优先搜索，就是按照深度优先的顺序对 “问题状态空间” 进行搜索的算法。

### 剪枝

剪枝，就是减小搜索树规模，尽早排除搜索树中不必要分支的手段。形象地看，就好像减掉了搜索树的枝条，故称为剪枝。在深度优先搜索中，常用的剪枝方法有：

- 优化搜索顺序
    - 从分支少的分支开始搜索。
- 排除等效冗余
    - 在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同的分支到达的子树是等效的，那么只需要对其中一条分支执行搜索。
- 可行性剪枝
    - 在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。
- 最优性剪枝
    - 如果搜索过程中发现当前解已经大于已经搜索到的最优解，就执行回溯。
- 记忆化
    - 可以记录每个状态的搜索结果，在重复遍历一个状态时直接检索并返回。

### 迭代加深

深度优先搜索每次选定一个分支，不断深度，直到达到递归边界才回溯。这种策略带有一定的缺陷。试想以下情况：搜索树每个节点的分支数目非常多，并且问题的答案在某个较浅的节点上。如果深搜在一开始选错了分支，就很可能在不包含答案的深层子树上浪费许多时间。

针对这种情况，我们可以从小到大限制搜索的深度，如果在当前深度限制下搜不到答案，就把深度限制增加，重新进行一次搜索，这就是迭代加深思想。所谓迭代，就是以上一次的结果为基础，重复执行以逼近答案的意思。

虽然该过程在深度限制为 d 时，会重复搜索第 1 ~ d-1 层的节点，但是当搜索树节点分支数目较多时，随着层数的深入，每层节点树会呈指数级增长。因此，虽然有重复搜索，但效率仍然要比直接搜索高。

总而言之，当搜索树规模随着层次的深入增长很快，并且我们能够确保答案在一个较浅层的节点时，就可以采用迭代加深的深度优先搜索算法来解决问题。

### 双向搜索

除了迭代加深之外，双向搜索也可以避免在深层子树上浪费时间。从初态和终态出发各搜索一半状态，产生两颗深度减半的搜索树，在中间交会、组合成最终答案。

### IDA\*

这个算法相当于在迭代加深中加入一个剪枝策略，若当前深度 +  未来估计步数 > 深度限制，则立即从当前分支回溯。明显，估计步数的值不能大于未来实际步数。