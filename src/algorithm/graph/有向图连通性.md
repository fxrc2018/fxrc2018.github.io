## 有向图连通性

给定有向图$$G=(V,E)$$，若存在$$r \in V$$，满足从 r 出发能够到达 V 中所有的点，则称 G 是一个 “流图”，记为 (G,r)，其中 r 称为流图的源点。

在一个流图 (G,r) 上从 r 出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 (x,y)（换言之，从 x 到 y 是对 y 的第一次访问）构成一颗以 r 为根的树，我们把它称为流图 (G,r) 的搜索树。

同时，在深度优先遍历的过程中，按照每个节点第一次访问的时间顺序，依次给予流图中 N 个节点 1~N 的整数标记，该标记被称为时间戳，记为 dfn[x]。

流图中的每条有向边 (x,y) 必然是以下四种之一：

1. 树枝边，指搜索树中 x 是 y 的父节点，是搜索树上的边。
2. 前向边，指搜索树中 x 是 y 的祖先节点。
3. 后向边，指搜索树中 y 是 x 的祖先节点。
4. 横叉边，指除了以上三种情况之外的边，它一定满足 dfn[y] < dfn[x]。

### 有向图的强连通分量

给定一张有向图。若对于图中任意两个两个节点 x,y，既存在从 x 到 y 的路径，也存在从 y 到 x 的路径，则称该有向图是 “强连通图”。

有向图的极大强连通子图被称为 “强连通分量”，简记为 SCC(Strongly Connected Component)。

Tarjan算法基于有向图的深度优先遍历，能够在线性时间内求出一张有向图的各个强连通分量。

一个 “环” 一定是强连通图。如果既存在从 x 到 y 的路径，也存在从 y 到 x 的路径，那么 x,y 显然在一个环中。因此，Tarjan算法的基本思路就是对于每个点，尽量找到与它一起能构成环的所有节点。

容易发现，“前向边” (x,y) 没有什么用处，因为搜索树上本来就存在从 x 到 y 的路径。“后向边” (x,y) 非常有用，因为它可以和搜索树上从 y 到 x 的路径一起构成环。“横向边” (x,y) 视情况而定，如果从 y 出发能够找到一条路径回到 x 的祖先节点，那么 (x,y) 就是有用的。

为了找到通过 “后向边” 和 “横叉边” 构成的环，Tarjan 算法在深度优先遍历的同时维护了一个栈。当访问到节点 x 时，栈中需要保存以下两类节点：

1. 搜索树上 x 的祖先节点，记为集合 anc(x)。如果 y 在 anc(x) 中，且存在后向边 (x,y)，则 (x,y) 与 y 到 x 的路径一起形成环。
2. 已经访问过的，并且存在一条路径到达 anc(x) 的节点。设 z 是一个这样的点，从 z 出发存在一条路径到达 y， y在 anc(x) 中。若存在横叉边 (x,z)，则 (x,z)、z 到 y 的路径、y到 x 的路径形成一个环。

综上所述，栈中的节点就是能与从 x 出发的 “后向边” 和 “横叉边” 形成环的节点。进而可以引入 “追溯值” 的概念。

设 subtree(x) 表示流图的搜索树中以 x 为根的子树。x 的追溯值 low[x] 定义为满足以下条件的节点的最小时间戳：

1. 该点在栈中。
2. 存在一条从 subtree(x) 出发的有向边，以该点为终点。

根据定义，Tarjan 算法按照以下步骤计算 “追溯值”：

1. 当节点 x 第一次被访问时，把 x 入栈，初始化 low[x] = dfs[x]。
2. 扫描从 x 出发的每条边 (x,y)。
    1. 若 y 没被访问过，则说明 (x,y) 是树枝边，递归访问 y，从 y 回溯后，令 low[x] = min(low[x], low[y])。
    2. 若 y 被访问过并且 y 在栈中，则令 low[x] = min(low[x], low[y])。
3. 从 x 回溯之前，判断是否有 low[x] = dfn[x]。若成立，则不断从栈中弹出节点，直至 x 出栈。

在追溯值得计算过程中，若从 x 回溯前，有 low[x] = dfn[x] 成立，则栈中从 x 到栈顶的所有节点构成一个强连通分量。