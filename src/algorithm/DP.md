## 动态规划

动态规划与分治方法相似，都是通过组合子问题的解来求解原问题。分治法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会做许多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。

### 动态规划的基本思路

动态规划可以这样理解：

* 动态规划 = 小心的暴力枚举。（DP = “careful brute force”）
* 动态规划 = 枚举 + 递归 + 记忆化。（DP = guessing + recursion + memorization）

解决动态规划问题主要有以下几个步骤：

1. 定义子问题。
2. 只考虑当前情况下，枚举所有的可能，然后选择一个最好的。
3. 解决相关的子问题。
4. 使用递归+记忆化的方式解决，或者使用动态规划表，自底向上的解决。这里需要检查子问题是不是有环的。
5. 解决基本情况。

时间复杂度 = 子问题的个数 * 解决子问题花费的时间。

这里最难的一点是定义子问题。如果输入是字符串或者数组的时候，子问题通常为下面三种情况之一：

* 后缀，从i开始到字符串结尾。
* 前缀，从0开始到i。
* 子串，从i到j。

我想用下面一个例子来说明这种思路的应用。

给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左和最右的纸牌，玩家A和玩家B绝顶聪明。请返回最后的获胜者的分数。

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N = 5000 + 10;
int arr[N];
int sum[N];
int f[N][N]; //先手取获得的最大值

int process(int l,int r){
    if(r <= l){
        return f[l][l] = arr[l];
    }
    if(f[l][r] != -1){
        return f[l][r];
    }
    //枚举取左边和取右边的情况
    f[l][r] = (sum[r] - sum[l-1]) - min(process(l+1, r),process(l,r-1));
    return f[l][r];
}

int main(){
    int n;
    memset(f,-1,sizeof(f));
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        sum[i] = sum[i-1] + arr[i];
    }
    process(1,n);
    printf("%d",max(f[1][n],sum[n] - f[1][n]));
    return 0;
}
```

可以看出，用这种思路写出的代码是记忆化搜索的形式，但一般的动态规划都是递推的形式。我觉得直接写递推通常是没有思路的，记忆化搜索能提供一些思路，但对于一些常见的动态规划题目，是可以直接写出递推的形式的。