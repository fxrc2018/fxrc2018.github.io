### Quake3快速平方根倒数算法

最近看了Quake3中快速平方根倒数的算法，感觉相当惊艳，记录下来，[原视频地址](https://www.youtube.com/watch?v=p8u_k2LIZyo&list=LL&index=1&t=882s)。

首先，为什么要计算平方根倒数，这主要是因为在游戏开发中经常要用到向量的归一化操作，因此，快速平方根倒数的计算速度对游戏性能的影响相当大，该算法要比`sqrt`函数快3倍左右。

这个算法的核心思想是，首先通过近似计算得到一个精度较低的值，然后通过牛顿法提高该精度。那么，怎么计算出一个精度较低的值呢，注意到：

$$
\log({\frac{1}{\sqrt{x}}}) = -\frac{1}{2}\log(x)
$$

这样，除以2可以用移位运算来做。也就是说，在对数领域，计算$$\frac{1}{\sqrt{x}}$$是比较容易了，还差一步，就是快速实现对数和原数的转化，该算法利用了浮点数表示和整数表示在比特表示的特点，实现了这种快速转换。

```cpp
float InvSqrt(float x){
    float xhalf = 0.5f*x;
    int i = *(int*)&x; // get bits for floating value
    i = 0x5f3759df - (i>>1); // gives initial guess y0
    x = *(float*)&i; // convert bits back to float
    x = x*(1.5f-xhalf*x*x); // Newton step, repeating increases accuracy
    return x;
}
```

首先，根据IEEE 754标准，单精度的浮点数由1位符号位，8位指数位，和23位尾数位组成。因为求平方根的时候，数都大于0，所以符号位永远为0，这里就不考虑了。记指数为E，尾数位M，其表示的数字为：

$$
(1+\frac{M}{2^{23}})*2^{E-127}
$$

对上面的等式取对数，并化简，可得：

$$
\log_2(1+\frac{M}{2^{23}}) + E - 127
$$

上面的式子可以近似一下，根据高等数学的知识，

$$
\log_2(1+x)  \approx x + \mu 
$$

所以，上面的等式可以变换为:

$$
\frac{M}{2^{23}} + \mu + E - 127
$$

进一步，可以写成下面的形式：

$$
\frac{1}{2^{23}}(M + 2^{23} * E) + \mu - 127
$$

为什么要写成这种形式呢，注意到，如果把一个浮点数看成一个整数，那么该整数表示的值恰好为：$$M + 2^{23} * E$$，所以，如果把一个浮点数看成一个整数，比特表现形式和取对数非常相似。

已知$$\log(y)$$的情况下， 计算$$\log{\frac{1}{\sqrt{x}}} = -\frac{1}{2}\log(x)$$比较简单。但这样做并不是真正的取对数，还需要对其进行修正。

另$$y=\frac{1}{\sqrt{x}}$$，则

$$
\log{y}=\log{\frac{1}{\sqrt{x}}}=-\frac{1}{2}\log{x}
$$

将其替换为比特表示：

$$
\frac{1}{2^{23}}(M_y + 2^{23} * E_y) + \mu - 127 = -\frac{1}{2}(\frac{1}{2^{23}}(M + 2^{23} * E) + \mu - 127)
$$

解得：

$$
(M_y + 2^{23} * E_y) = \frac{3}{2}2^{23}(127 - \mu) - \frac{1}{2}(M_x+2^{23}*E_x)
$$

可以看到，上面的说明对应下面两句代码。$$\mu$$的取值为0.043左右，后面精度太多就不写了，这个主要是为了提高精度。

```cpp
i = 0x5f3759df - (i>>1); // gives initial guess y0
x = *(float*)&i; // convert bits back to float
```

这样得到的值精度还不是很够，还需要进行一次牛顿法迭代。

$$
x_{new} = x - \frac{f(x)}{f^{\prime}(x)}
$$

记原来的值为$$a$$，则：

$$
f(x) = \frac{1}{x^2} - a
$$

这样，代码就写完了。

这个算法让我大开眼界，让我明白了，啊，原来算法还可以这样玩。说实话，对于中间的某些步骤我还不太清楚，先记录下来吧。