## 屏幕后处理效果

### 调整屏幕的亮度、饱和度和对比度

```cpp
#iChannel0 "file://sakura0.jpg"

float brightness = 1.0; // 亮度
float saturation = 1.0; // 饱和度
float contrast = 1.0; // 对比度

void mainImage(out vec4 fragColor, in vec2 fragCoord){
    vec2 uv = fragCoord.xy / iResolution.xy;
    vec4 textureColor = texture(iChannel0, uv);
    
    // 亮度
    vec3 finalColor = textureColor.rgb * brightness;
    
    // 饱和度
    float luminance = 0.2125 * textureColor.r + 0.7154 * textureColor.g + 0.0721 * textureColor.b;
    vec3 luminanceColor = vec3(luminance);
    finalColor = mix(luminanceColor, finalColor, saturation);
    
    // 对比度    
    vec3 avgColor = vec3(0.5,0.5,0.5);
    finalColor = mix(avgColor,finalColor,contrast);

    fragColor = vec4(finalColor,textureColor.a);
}
```

### 边缘检测

```cpp
#iChannel0 "file://sakura0.jpg"

vec4 edgeColor = vec4(0.0,0.0,0.0,1.0);
vec4 bgColor = vec4(1.0);
float edgeOnly = 0.0;

float luminance(vec4 color){
    return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;
}

float sobel(vec4 textureColors[9]){
    const float GX[9] = float[9](
        -1.0,-2.0,-1.0,
        0.0,0.0,0.0,
        1.0,2.0,1.0);
    const float GY[9] = float[9](
        -1.0,0.0,1.0,
        -2.0,0.0,2.0,
        -1.0,0.0,1.0);
    float edgeX = 0.0;
    float edgeY = 0.0;
    float textureColor;
    for(int i=0;i<9;i++){
        textureColor = luminance(textureColors[i]);
        edgeX += textureColor * GX[i];
        edgeY += textureColor * GY[i];
    }
    // edge值越大，该点越有可能是
    float edge = 1.0 - abs(edgeX) - abs(edgeY);
    return edge;
}

void main(){
    vec4 textureColors[9];
    // 计算相邻的纹理坐标
    vec2 firstPos = gl_FragCoord.xy - vec2(1.0,1.0);
    for(int i=0;i<9;i++){
        vec2 offset = vec2(i%3,i/3);
        vec2 uv = (firstPos + offset) / iResolution.xy;
        textureColors[i] = texture(iChannel0,uv);
    }
    float edge = sobel(textureColors);
    vec4 withEdgeColor = mix(edgeColor,textureColors[4],edge);
    vec4 onlyEdgeColor = mix(edgeColor,bgColor,edge);
    vec4 finalColor = mix(withEdgeColor,onlyEdgeColor,edgeOnly);
    gl_FragColor = finalColor;
}
```

### 高斯模糊

```cpp
#iChannel0 "file://sakura0.jpg"

#ifdef GL_ES
precision mediump float;
#endif

float normpdf(in float x, in float sigma)
{
	return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;
	if (fragCoord.x < iMouse.x)
	{
		fragColor = vec4(c, 1.0);	
	} else {
		
		//declare stuff
		const int mSize = 11;
		const int kSize = (mSize-1)/2;
		float kernel[mSize];
		vec3 final_colour = vec3(0.0);
		
		//create the 1-D kernel
		float sigma = 7.0;
		float Z = 0.0;
		for (int j = 0; j <= kSize; ++j)
		{
			kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);
		}
		
		//get the normalization factor (as the gaussian has been clamped)
		for (int j = 0; j < mSize; ++j)
		{
			Z += kernel[j];
		}
		
		//read out the texels
		for (int i=-kSize; i <= kSize; ++i)
		{
			for (int j=-kSize; j <= kSize; ++j)
			{
				final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;
	
			}
		}
		
		
		fragColor = vec4(final_colour/(Z*Z), 1.0);
	}
}
```

### Bloom

```cpp
#iChannel0 "file://sakura0.jpg"


vec4 BlurColor (in vec2 Coord, in sampler2D Tex, in float MipBias)
{
	vec2 TexelSize = MipBias/iChannelResolution[0].xy;
    
    vec4  Color = texture(Tex, Coord, MipBias);
    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias);    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias);    	
    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias);    	
    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias);    	
    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias);    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias);    	
    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias);    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias);    

    return Color/9.0;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
float Threshold = 0.0+iMouse.y/iResolution.y*1.0;
float Intensity = 2.0-iMouse.x/iResolution.x*2.0;
float BlurSize = 6.0-iMouse.x/iResolution.x*6.0;
	vec2 uv = (fragCoord.xy/iResolution.xy)*vec2(1.0,-1.0);
    
    vec4 Color = texture(iChannel0, uv);
    
    vec4 Highlight = clamp(BlurColor(uv, iChannel0, BlurSize)-Threshold,0.0,1.0)*1.0/(1.0-Threshold);
        
    fragColor = 1.0-(1.0-Color)*(1.0-Highlight*Intensity); //Screen Blend Mode
}
```