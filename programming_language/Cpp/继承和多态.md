C++很重要的一个特征就是代码重用。在C语言中重用代码的方式就是拷贝、修改代码。C++可以用继承或组合的方式来重用。通过组合或继承现有的类来创建新类，而不是重新创建它们。

##单继承
继承是使用已经编写好的类来创建新类，新的类具有原有类的所有属性和操作，可以在原有类的基础上作一些修改和增补。值得注意的是，有以下的一些成员函数不能自动继承：构造函数、析构函数、=运算符。新类称为派生类或子类，原有类称为基类或父类，派生类是基类的具体化。派生类的声明语法如下。
```
class 派生类名：继承方式 基类名
{
	派生类新增成员的声明； //可以是数据，也可以是函数
}
```
这里，继承方式有3种，公有，保护和私有。它们的含义是，父类成员的访问权限如果比继承方式高，那么会降级为继承方式。也就是说，如果继承方式为保护，那么父类的公有成员就变成了保护成员。

我们将类的公有成员函数称为接口。公有继承，基类的公有成员函数在派生类中仍然是公有的，换句话说，基类的接口成为了派生类的接口，因而将它称为接口继承。对于私有、保护继承，派生类不能继承基类的接口。派生类将不再支持基类的公有接口，它希望能重用基类的实现而已，因而将它称为实现继承。

基类的构造函数不被继承，派生类中需要声明自己的构造函数。声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化通过调用基类构造函数完成。派生类的构造函数中需要给基类的构造函数传递参数。

如果在派生类中声明了和基类中名称一样的数据或函数（不是虚函数）叫做重定义。如果需要访问基类的成员，需要加上作用域运算符。请看下面的这个例子。

```
#include <iostream>
using namespace std;

class A{
public:
    int a_;
    A(int a):a_(a){}
};

class B:public A{
public:
    int a_;
    int b_;
    B(int a,int b):A(a+1),a_(a),b_(b){}
};

int main(int argc, char const *argv[])
{
    B b(1,100);
    cout<<b.a_<<" "<<b.b_<<endl;
    cout<<b.A::a_<<endl;
    return 0;
}
```

代码重用可以通过在一个类中含有另一个类对象来实现，这种方式叫做组合。所以，无论是继承还是组合，本质上都是把子对象放在新类型中，两者都是使用构造函数的初始化列表去构造这些子对象。组合是希望新类内部具有已存在的类的功能，而不是希望已存在类作为它的接口。组合通过嵌入一个对象来实现新类的功能，而新类用户看到的是新定义的接口，而不是来自老类的接口（**has-a**）。如果希望新类与已存在的类有相同的接口（在这基础上可以增加自己的成员）。这时候需要用继承，也称为子类型化（**is-a**）。

##类型转换
派生类对象也是基类对象。这意味着在使用基类的地方也可以使用派生类来替换。公有继承时，编译器可自动执行以下转换：派生类对象指针（引用）自动转化为基类对象指针（引用）；派生类对象自动转化为基类对象（特有的成员消失）。

当保护、私有继承时，派生对象指针（引用）转化为基类对象指针（引用）需用强制类型转化。但不能用static_cast，要用reinterpret_cast。

不能把派生类对象强制转换为基类对象，当基类对象指针（引用）可强制类型转换为派生类对象指针（引用）。值得注意的是，向下转型不安全，没有自动转换的机制。


##RTTI（Run-Time Type Identification）
RTTI（运行时类型识别）的功能由两个运算符实现。

* typeid运算符，用于返回表达式的类型。
* dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。

它们的简单示例如下。
```
int main(int argc, char const *argv[])
{
    A *a = new B();
    if(B *b = dynamic_cast<B*>(a)){
        b->func();
    }
    const type_info &info1 = typeid(a);
    cout<<info1.name()<<endl;
    return 0;
}
```

##多重继承和虚继承

C++还支持多重继承，即一个派生类可以有多个基类。它的语法如下。

```
class 类名：继承方式 基类1，继承方式 基类2，...
{
    派生类新增成员的声明；
}
```
多重继承同时继承多个基类的成员，更好的软件重用。但多重继承可能会有大量的二义性，多个基类中可能包含同名变量或函数。要解决歧义的问题可以使用作用域运算符明确指定要访问哪个基类中的成员来解决。

当派生类从多个基类派生，而这些基类又从同一个基类派生，这时，派生类会有多个基类的基类的拷贝。如下面的代码。
```
#include <iostream>
using namespace std;

class A{
public:
    int val_;
    A(int val):val_(val){}
};

class B:public A{
public:
    B(int val):A(val){}
};

class C:public A{
public:
    C(int val):A(val){}
};

class D:public B,public C{
public:
    D(int b, int c):B(b),C(c){}
};

int main(int argc, char const *argv[])
{
    D d(1,2);
    // cout<<d.val_<<endl; //ambiguous
    cout<<d.B::val_<<" "<<d.C::val_<<endl;
    system("pause");
    return 0;
}
```

这时候，可以通过使用作用域操作符来避免歧义，但是却无法避免产生多个A类的对象。为了解决这个问题，C++引入了虚基类。虚基类的声明比较简单，继承的时候使用virtual修饰基类即可，如class A：virtual public B。虚基类解决了多继承时可能发生的对同一基类继承多次而产生的二义性问题。为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝。

虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。在整个继承结构中，直接过间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的默认构造函数。在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，该派生类的其他虚基类构造函数的调用被忽略。

可以使用虚基类把上面的例子改写。

```
#include <iostream>
using namespace std;

class A{
public:
    int val_;
    A(int val):val_(val){}
};

class B:virtual public A{
public:
    B(int val):A(val){}
};

class C:virtual public A{
public:
    C(int val):A(val){}
};

class D:public B,public C{
public:
    D(int a,int b, int c):A(a),B(b),C(c){}
};

int main(int argc, char const *argv[])
{
    D d(1,2,3);
    cout<<d.val_<<endl; //the result is 1
    return 0;
}
```

##多态和虚函数
多态性是面向对象程序设计的重要特征之一。多态性是指发出同样的消息被不同类型的对象接收时可能导致完全不同的行为。多态是通过动态绑定来实现的，也就是绑定过程在程序运行时完成，在程序运行时才确定将要调用的函数。相对应的是静态绑定，绑定过程出现在编译阶段，在编译期就已确定要调用的函数。

虚函数，即在基类中使用virtual关键字修饰的成员函数，虚函数的定义如下。
```
class 类名{
    virtual 函数类型 函数名称（参数列表）;
};
```
如果一个函数在基类中被声明为虚函数，则他在所有派生类中都是虚函数。只有通过基类指针或引用调用虚函数才能引发动态绑定。虚函数不能声明为静态。

虚函数中还需要说明的是虚析构函数，构造函数不能是虚函数，但析构函数可以是虚函数。当通过一个基类指针删除一个派生类对象时，如果希望调用派生类的构造函数，需要将基类的析构函数定义为虚析构函数。下面是一个具体的例子。

```
#include <iostream>
using namespace std;

class A{
public:
    int val_;
    virtual void func(){
        cout<<"A::func()"<<endl;
    }
    A(int val):val_(val){}
    virtual ~A(){
        cout<<" ~A()"<<endl;
    }
};

class B: public A{
public:
    void func(){
        cout<<"B::func()"<<endl;
    }
    B(int val):A(val){}
    ~B(){
        cout<<" ~B()"<<endl;
    }
};

int main(int argc, char const *argv[])
{
    A *a = new B(1);
    a->func();/* 调用B::func() */
    B b(2);
    A a1 = b;
    a1.func(); /* 调用A::func(),发生了对象的裁剪 */
    delete a; /* 会调用B类的析构函数，如果去掉~A()的virtual关键字则不会 */
    return 0;
}
```

##纯虚函数和抽象类

虚函数是实现多态的前提，所以，我们可以在基类中定义共同的接口，即把成员函数定义为虚函数。但有时候在基类中不能给出有意义的虚函数定义，如形状类shape有一个draw方法，但是基类是没有形状的，所以无法实现draw方法。这时候，可以将这些接口定义为纯虚函数，也就是说，它是没有意义的，它的定义需要派生类来实现，所以纯虚函数不需要实现。纯虚函数的声明形式如下。
```
class 类名{
    virtual 返回值类型 函数名（参数表） = 0;
}
```

抽象类就是至少有一个纯虚函数的类。抽象类无法创建对象，就像你无法画出一个抽象的形状，从编程角度来说，抽象类中含有没有给出实现的纯虚函数，所以抽象类是不完整的，因此无法创建对象。抽象类的作用是将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。抽象类不能用于字节创建对象实例，可以声明抽象类的指针和引用。可使用指向抽象类的指针支持运行时多态性。派生类中必须实现基类中的纯虚函数，否则它仍将被看做一个抽象类。



##重载、重写和重定义

* 重载是发生在相同的范围（如同一个类中），必须满足函数名称相同且参数不同，virtual关键字不影响函数的重载。
* 重写是发生在派生类和基类中，基类函数必须使用virtual关键字修饰，需要满足函数名称相同且参数相同。
* 重定义发生在派生类和基类中，必须满足函数相同名且参数相同，并且基类函数无virtual关键字。

请看下面这个例子。
```
#include <iostream>
using namespace std;

class A{
public:
    virtual void func(){
        cout<<"A::func()"<<endl;
    }
    void func(int a){ /* 重载 */
        cout<<"A::func(int a)"<<endl;
    }
};

class B:public A{
public:
    void func(){ /* 重写 */
        cout<<"B::func()"<<endl;
    }

    void func(int a){ /* 重定义 */
        cout<<"B::func(int a)"<<endl; 
    }

    void func(char c){ /* 重载，子类新增一个定义 */
        cout<<"B::func(char c)"<<endl;
    }
};


int main(int argc, char const *argv[])
{
    B b;
    b.func();
    b.A::func(); /* 虚函数也可以这样强制调用 */
    b.func(1);
    b.A::func(1);
    b.func('A');
    return 0;
}
```
