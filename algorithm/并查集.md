## 并查集

并查集(Disjoint Set)是一种非常精巧而且实用的数据结构，它主要用于处理一些不相交集合的合并问题。

这个数据结构我也写过，但写得远不如书上的精巧。首先，合并的时候，树高度低的向高度高的合并，以前写的方式是用一个额外的数组记录高度，但可以利用数组的编号都为正数的特点，用一个负数表示树的高度。

然后，查找的时候，可以顺便做一下路径压缩。

```cpp
#include <vector>
using namespace std;

class DisjSets{
public:
    explicit DisjSets(int numElements):s(numElements,-1){};
    int find(int x){
        if(s[x] < 0){
            return x;
        }else{
            return s[x] = find(s[x]); //路径压缩
        }
    }
    void unionSets(int root1, int root2){
        if(s[root2] < s[root1]){ //高度低的合并到高度高的
            s[root1] = root2;
        }else{
            if(s[root1] == s[root2]){
                --s[root1];
            }
            s[root2] = root1;
        }
    }
private:
    vector<int> s;
};
```

```cpp
#include <iostream>
#include <cstring>
#include <string>
using namespace std;

const int N = 1e5 + 10;
int arr[N];

int find(int x){
    if(arr[x] < 0){
        return x;
    }
    return arr[x]= find(arr[x]);
}

void merge(int x,int y){
    if(find(x) != find(y)){
        arr[find(y)] += arr[find(x)];
        arr[find(x)] = find(y);
    }

}

int main(){
    int n,m;
    memset(arr,-1,sizeof(arr));
    scanf("%d%d",&n,&m);
    string op;
    int x,y;
    for(int i=0;i<m;i++){
        cin>>op>>x;
        // cout<<op<<x<<y<<endl;
        if(op == "C"){
            cin>>y;
            merge(x,y);
            // printf("%d %d\n",find(x),find(y));
        }else if(op == "Q1"){
            cin>>y;
            if(find(x) == find(y)){
                printf("Yes\n");
            }else{
                printf("No\n");
            }
        }else if(op == "Q2"){
            printf("%d\n",-arr[find(x)]);
        }
    }
    return 0;
}
```